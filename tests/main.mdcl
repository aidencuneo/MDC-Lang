scb : '{';
ecb : '}';

sb : '(';
eb : ')';

error : [text,] => {
    echo(text);
    "\n";
    exit();
}

cbstrip : [str,] => {
    if (str[0] = scb) and (str[-1] = ecb) do str : str[1:-1];
    ret str.strip("\n\t ");
}

bstrip : [str,] => {
    if (str[0] = sb) and (str[-1] = eb) do str : pyeval(pretty(str) + '[1:-1]');
    ret str.strip("\n\t ");
}

compile : [text, scope*, canEcho*, inline*] => {
    compiled : '';
    lines : tokeniseFile(text);
    scope : scope?scope\0;
    canEcho : canEcho?true\false;
    inline : inline?true\false;

    for i : lines {
        line : ();
        last : '';
        for tokenise(i) {
            done : false;
            if (#.startswith(sb)) and (#.endswith(eb)) {
                if !(last = ':') {
                    n : sb + (compile(bstrip(#), 0, false, false).strip("\n ")) + eb;
                    line +: n;
                    last : n;
                    done : true;
                }
            }
            if # = 'true' {
                n : 'True';
                line +: n;
                last : n;
                done : true;
            }
            if # = 'false' {
                n : 'False';
                line +: n;
                last : n;
                done : true;
            }
            if # = 'null' {
                n : 'None';
                line +: n;
                last : n;
                done : true;
            }
            if # = '=' {
                n : '==';
                line +: n;
                last : n;
                done : true;
            }
            if # = '#' {
                n : '__';
                line +: n;
                last : n;
                done : true;
            }
            if (!done) {
                line +: #;
                last : #;
            }
        }

        if len(line) < 1 do line +: null;

        line; "\n";

        done : false;
        if line has ':' {
            if (!inline) do
                compiled +: scope * ' ';
            idone : false;
            if line[0] = 'for' {
                compiled +: 'for ' + (line[1]) + ' in ';
                index : 0;
                for line {
                    if # = ':' do break;
                    index +: 1;
                }
                c : '';
                for index + 1 to (len(line) - 2) do c +: line[#] + ' ';
                c : compile(c, 0, false, true);
                compiled +: 'iterate(' + c + "):\n";
                compiled +: compile(cbstrip(line[-1]), scope + 4, true);
                idone : true;
            }
            if (!idone) and (line has '=>') {
                compiled +: 'def ' + (line[0]) + '(' +
                    (line[2].strip('[]')) + "):\n";
                compiled +: compile(cbstrip(line[4]), scope + 4, true) + "\n";
                idone : true;
            }
            if (!idone) {
                start : '';
                index : 0;
                for line {
                    if # = ':' do break;
                    start +: #;
                    index +: 1;
                }
                compiled +: start + ' = ';
                c : '';
                for index + 1 to (len(line) - 1) do c +: line[#] + ' ';
                compiled +: compile(c, 0, false, true).strip();
                compiled +: "\n";
                idone : true;
            }
            done : true;
        }
        if (!done) and (line has '+:') {
            start : '';
            index : 0;
            for line {
                if # = '+:' do break;
                start +: #;
                index +: 1;
            }
            compiled +: start + ' += ';
            c : '';
            for index + 1 to (len(line) - 1) do c +: line[#] + ' ';
            compiled +: compile(c, 0, false, true).strip();
            compiled +: "\n";
            done : true;
        }
        if (!done) and (line has '-:') {
            start : '';
            index : 0;
            for line {
                if # = '-:' do break;
                start +: #;
                index +: 1;
            }
            compiled +: start + ' -= ';
            c : '';
            for index + 1 to (len(line) - 1) do c +: line[#] + ' ';
            compiled +: compile(c, 0, false, true).strip();
            compiled +: "\n";
            done : true;
        }
        if (!done) and (line has '*:') {
            start : '';
            index : 0;
            for line {
                if # = '*:' do break;
                start +: #;
                index +: 1;
            }
            compiled +: start + ' *= ';
            c : '';
            for index + 1 to (len(line) - 1) do c +: line[#] + ' ';
            compiled +: compile(c, 0, false, true).strip();
            compiled +: "\n";
            done : true;
        }
        if (!done) and (line has '/:') {
            start : '';
            index : 0;
            for line {
                if # = '/:' do break;
                start +: #;
                index +: 1;
            }
            compiled +: start + ' /= ';
            c : '';
            for index + 1 to (len(line) - 1) do c +: line[#] + ' ';
            compiled +: compile(c, 0, false, true).strip();
            compiled +: "\n";
            done : true;
        }
        if (!done) and (('if', 'while') has (line[0])) {
            compiled +: scope * ' ';
            compiled +: line[0] + ' ';
            index : -1;
            for line {
                if (#.startswith(scb)) and (#.endswith(ecb)) do
                    break;
                index +: 1;
            }
            for 1 to index do compiled +: line[#] + ' ';
            compiled : compiled.rstrip();
            compiled +: ":\n";
            compiled +: compile(cbstrip(line[index]), scope + 4);
            done : true;
        }
        if (!done) and (line[0] = 'for') {
            compiled +: 'for __ in ';
            c : '';
            for 1 to (len(line) - 2) do c +: line[#] + ' ';
            c : compile(c, 0, false, true);
            compiled +: 'iterate(' + c + "):\n";
            compiled +: compile(cbstrip(line[-1]), scope + 4, true);
            done : true;
        }
        if (!done) and (len(line) > 1) {
            idone : false;
            if (line[1].startswith(sb)) and (line[1].endswith(eb)) {
                echoable : true;
                first : line[0];
                write('first: ' + first);
                if fKeys has first {
                    index : 0;
                    for fKeys {
                        if # = first do break;
                        index +: 1;
                    }
                    first : fVals[index];
                }
                write('secnd: ' + first);
                if ('print', 'echo') has first do echoable : false;
                compiled +: scope * ' ';
                c : '';
                for 1 to (len(line) - 1) do c +: line[#] + ' ';
                c : first + (compile(c, 0, false, true));
                compiled +: (canEcho and echoable) ?
                    "print(" + c + ", end='')\n" \ c;
                compiled +: "\n";
                idone : true;
            }
            if (!idone) and (line[0] = 'ret') {
                compiled +: scope * ' ' + 'return ';
                for 1 to (len(line) - 1) {
                    if type(line[#]) = 'String' do
                        compiled +: line[#] + ' ';
                }
                compiled : compiled.rstrip();
                idone : true;
            }
            if (!idone) and inline {
                c : ' '.join(line);
                c; "\n";
                compiled +: canEcho ?
                    "print(" + c + ", end='')\n" \ c;
                compiled : compiled.rstrip();
                idone : true;
            }
            if (!idone) {
                c : compile(' '.join(line), 0, false, true);
                c; "\n";
                compiled +: canEcho ?
                    "print(" + c + ", end='')\n" \ c;
                idone : true;
            }
            done : true;
        }
        if (!done) and (len(line) = 1) {
            for line {
                if type(#) = 'String' {
                    compiled +: scope * ' ';
                    compiled +: canEcho ?
                        "print(" + # + ", end='')\n" \ #;
                }
            }
            done : true;
        }

    }
    ret compiled;
}

fKeys : ('write', 'exit', 'string', 'date');
fVals : ('print', 'sys.exit', 'str', 'Date');

this : argv(1);
code : readfile(this);

compiled : readfile('src/compact.py') + "\n";
compiled +: readfile('src/loader.py') + "\n";
compiled +:
    readfile('src/var.py')
    .replace('loader.', '')
    .replace("import loader\n", '')
    .replace("from compact import CompactList, CompactDict\n", '')
    .replace("_is_compiled = False\n", "_is_compiled = True\n")
    + "\n";
compiled +: "import functools\n" +
    "fname = os.path.abspath(sys.argv[0])\n" +
    "dirname = os.path.dirname(fname)\n" +
    "src_path = sys.path[0] if _debug_mode else os.path.dirname(sys.path[0])\n" +
    "initialise_path(src_path, dirname, compiled=True)\n\n";
compiled +: "def iterate(arg):\n" +
    "    if isinstance(arg, int):\n" +
    "        arg = range(arg)\n" +
    "    return arg\n";
compiled +: "def call(func, args=None):\n" +
    "    return call_function(local_vars[func], args)\n\n";
compiled +: "for a in local_vars:\n" +
    "    exclude = ['len', 'type', 'locals', 'globals', 'exec', 'eval', 'int', 'float']\n" + 
    "    if type(local_vars[a]) in (Function, BuiltinFunction) and a not in globals().keys() and a not in exclude:\n" +
    "        exec(a + '=functools.partial(call, ' + pformat(a) + ')')\n\n";
compiled +: compile(code, 0, true) + "\n";
writefile('.'.join(this.split('.')[:-1]) + '.py', compiled.strip() + "\n");
